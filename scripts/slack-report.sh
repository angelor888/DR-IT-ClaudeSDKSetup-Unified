#!/bin/bash
# Send formatted reports to Slack with machine identification
# Automatically adds sender information to all reports

set -euo pipefail

# Configuration
SLACK_TOKEN="${SLACK_TOKEN:-}"

# Check if token is set
if [ -z "$SLACK_TOKEN" ]; then
    echo -e "${RED}‚ùå SLACK_TOKEN not set. Please set it in your environment.${NC}"
    echo "export SLACK_TOKEN='your-token-here'"
    exit 1
fi
MACHINE_NAME=$(cat "$HOME/.claude-machine-id" 2>/dev/null || hostname -s)
MACHINE_UPPER=$(echo "$MACHINE_NAME" | tr '[:lower:]' '[:upper:]' | cut -c1)$(echo "$MACHINE_NAME" | cut -c2-)
TIMESTAMP=$(date "+%I:%M %p")
DATESTAMP=$(date "+%Y-%m-%d")

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

# Usage
usage() {
    echo "Usage: $0 <channel> <report-file>"
    echo "Examples:"
    echo "  slack-report #it-report daily-summary.md"
    echo "  slack-report #general status-update.txt"
    exit 1
}

# Check arguments
if [ $# -ne 2 ]; then
    usage
fi

CHANNEL="$1"
REPORT_FILE="$2"

# Validate file exists
if [ ! -f "$REPORT_FILE" ]; then
    echo -e "${RED}‚ùå File not found: $REPORT_FILE${NC}"
    exit 1
fi

# Read report content
REPORT_CONTENT=$(cat "$REPORT_FILE")

# Extract report title (first heading or first line)
REPORT_TITLE=$(echo "$REPORT_CONTENT" | grep -m1 "^#" | sed 's/^#\+\s*//' || echo "$REPORT_CONTENT" | head -1)

# Prepare Slack blocks with machine identification
BLOCKS=$(cat <<EOF
[
    {
        "type": "header",
        "text": {
            "type": "plain_text",
            "text": "$REPORT_TITLE",
            "emoji": true
        }
    },
    {
        "type": "context",
        "elements": [
            {
                "type": "mrkdwn",
                "text": "*Report from: $MACHINE_UPPER* | *Generated: $DATESTAMP at $TIMESTAMP*"
            }
        ]
    },
    {
        "type": "divider"
    }
]
EOF
)

# Convert markdown content to Slack blocks (simplified)
# Split content into sections and create blocks
SECTION_BLOCKS=""
while IFS= read -r line; do
    if [[ "$line" =~ ^##\s+(.+) ]]; then
        # Section header
        SECTION_BLOCKS+=",{\"type\":\"section\",\"text\":{\"type\":\"mrkdwn\",\"text\":\"*${BASH_REMATCH[1]}*\"}}"
    elif [[ "$line" =~ ^\*\*(.+)\*\* ]]; then
        # Bold text
        SECTION_BLOCKS+=",{\"type\":\"section\",\"text\":{\"type\":\"mrkdwn\",\"text\":\"$line\"}}"
    elif [[ -n "$line" ]]; then
        # Regular text
        SECTION_BLOCKS+=",{\"type\":\"section\",\"text\":{\"type\":\"mrkdwn\",\"text\":\"$line\"}}"
    fi
done <<< "$REPORT_CONTENT"

# Add footer with machine signature
FOOTER_BLOCK=$(cat <<EOF
,
    {
        "type": "divider"
    },
    {
        "type": "context",
        "elements": [
            {
                "type": "mrkdwn",
                "text": "ü§ñ *Generated by Claude on $MACHINE_UPPER* | *Unified Environment Active*"
            }
        ]
    }
EOF
)

# Combine all blocks
ALL_BLOCKS="${BLOCKS%]}"
ALL_BLOCKS+="$SECTION_BLOCKS"
ALL_BLOCKS+="$FOOTER_BLOCK"
ALL_BLOCKS+="]"

# Create JSON payload
JSON_PAYLOAD=$(cat <<EOF
{
    "channel": "$CHANNEL",
    "text": "$REPORT_TITLE - Report from $MACHINE_UPPER",
    "blocks": $ALL_BLOCKS
}
EOF
)

# Send to Slack
echo -e "${BLUE}üì§ Sending report to $CHANNEL...${NC}"

RESPONSE=$(curl -s -X POST https://slack.com/api/chat.postMessage \
    -H "Authorization: Bearer $SLACK_TOKEN" \
    -H "Content-Type: application/json" \
    -d "$JSON_PAYLOAD")

# Check response
if echo "$RESPONSE" | grep -q '"ok":true'; then
    echo -e "${GREEN}‚úÖ Report sent to $CHANNEL!${NC}"
    echo -e "${BLUE}Report identified as coming from: $MACHINE_UPPER${NC}"
    
    # Show message URL if available
    PERMALINK=$(echo "$RESPONSE" | jq -r '.permalink // empty' 2>/dev/null)
    if [ -n "$PERMALINK" ]; then
        echo -e "${YELLOW}View in Slack: $PERMALINK${NC}"
    fi
else
    echo -e "${RED}‚ùå Failed to send report${NC}"
    echo "$RESPONSE" | jq -r '.error // .' 2>/dev/null || echo "$RESPONSE"
    exit 1
fi